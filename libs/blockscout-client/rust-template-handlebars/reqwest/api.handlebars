{{>partial_header}}

use reqwest;
use serde::{Deserialize, Serialize};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration};

{{#with operations}}
{{#each operation}}
{{#if vendorExtensions.x-group-parameters}}
{{#each allParams}}
{{#if @first}}
/// struct for passing parameters to the method [`{{operationId}}`]
#[derive(Clone, Debug)]
pub struct {{{operationIdCamelCase}}}Params {
{{/if}}
    {{#with description}}
    /// {{{.}}}
    {{/with}}
    pub {{{paramName}}}: {{#unless required}}Option<{{/unless}}{{#if required}}{{#if isNullable}}Option<{{/if}}{{/if}}{{#unless isUuid}}{{#if isString}}{{#if isArray}}Vec<{{/if}}String{{#if isArray}}>{{/if}}{{/if}}{{/unless}}{{#if isUuid}}{{#if isArray}}Vec<{{/if}}String{{#if isArray}}>{{/if}}{{/if}}{{#unless isString}}{{#unless isUuid}}{{#unless isPrimitiveType}}{{#unless isContainer}}models::{{/unless}}{{/unless}}{{{dataType}}}{{/unless}}{{/unless}}{{#unless required}}>{{/unless}}{{#if required}}{{#if isNullable}}>{{/if}}{{/if}}{{#unless @last}},{{/unless}}
{{#if @last}}
}

{{/if}}
{{/each}}
{{/if}}
{{/each}}
{{/with}}

{{#if supportMultipleResponses}}
{{#with operations}}
{{#each operation}}
/// struct for typed successes of method [`{{operationId}}`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum {{{operationIdCamelCase}}}Success {
    {{#each responses}}
    {{#if is2xx}}
    Status{{code}}({{#if isEnum}}{{{enumName}}}{{/if}}{{#unless isEnum}}{{{dataType}}}{{/unless}}),
    {{/if}}
    {{#if is3xx}}
    Status{{code}}({{#if isEnum}}{{{enumName}}}{{/if}}{{#unless isEnum}}{{{dataType}}}{{/unless}}),
    {{/if}}
    {{/each}}
    UnknownValue(serde_json::Value),
}

{{/each}}
{{/with}}
{{/if}}
{{#with operations}}
{{#each operation}}
/// struct for typed errors of method [`{{operationId}}`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum {{{operationIdCamelCase}}}Error {
    {{#each responses}}
    {{#if is4xx}}
    Status{{code}}({{#if isEnum}}{{{enumName}}}{{/if}}{{#unless isEnum}}{{{dataType}}}{{/unless}}),
    {{/if}}
    {{#if is5xx}}
    Status{{code}}({{#if isEnum}}{{{enumName}}}{{/if}}{{#unless isEnum}}{{{dataType}}}{{/unless}}),
    {{/if}}
    {{#if isDefault}}
    DefaultResponse({{#if isEnum}}{{{enumName}}}{{/if}}{{#unless isEnum}}{{{dataType}}}{{/unless}}),
    {{/if}}
    {{/each}}
    UnknownValue(serde_json::Value),
}

{{/each}}
{{/with}}

{{#with operations}}
{{#each operation}}
{{#with description}}
/// {{{.}}}
{{/with}}
{{#if notes}}
/// {{{.}}}
{{/if}}
{{#if vendorExtensions.x-group-parameters}}
pub {{#if supportAsync}}async {{/if}}fn {{{operationId}}}(configuration: &configuration::Configuration{{#each allParams}}{{#if @first}}, params: {{{operationIdCamelCase}}}Params{{/if}}{{/each}}) -> Result<{{#if isResponseFile}}{{#if supportAsync}}reqwest::Response{{/if}}{{#unless supportAsync}}reqwest::blocking::Response{{/unless}}{{/if}}{{#unless isResponseFile}}{{#if supportMultipleResponses}}ResponseContent<{{{operationIdCamelCase}}}Success>{{/if}}{{#unless supportMultipleResponses}}{{#unless returnType}}(){{/unless}}{{{returnType}}}{{/unless}}{{/unless}}, Error<{{{operationIdCamelCase}}}Error>> {
{{/if}}
{{#unless vendorExtensions.x-group-parameters}}
pub {{#if supportAsync}}async {{/if}}fn {{{operationId}}}(configuration: &configuration::Configuration, {{#each allParams}}{{{paramName}}}: {{#unless required}}Option<{{/unless}}{{#if required}}{{#if isNullable}}Option<{{/if}}{{/if}}{{#if isString}}{{#if isArray}}Vec<{{/if}}{{#unless isUuid}}&str{{/unless}}{{#if isArray}}>{{/if}}{{/if}}{{#if isUuid}}{{#if isArray}}Vec<{{/if}}&str{{#if isArray}}>{{/if}}{{/if}}{{#unless isString}}{{#unless isUuid}}{{#unless isPrimitiveType}}{{#unless isContainer}}models::{{/unless}}{{/unless}}{{{dataType}}}{{/unless}}{{/unless}}{{#unless required}}>{{/unless}}{{#if required}}{{#if isNullable}}>{{/if}}{{/if}}{{#unless @last}}, {{/unless}}{{/each}}) -> Result<{{#if isResponseFile}}{{#if supportAsync}}reqwest::Response{{/if}}{{#unless supportAsync}}reqwest::blocking::Response{{/unless}}{{/if}}{{#unless isResponseFile}}{{#if supportMultipleResponses}}ResponseContent<{{{operationIdCamelCase}}}Success>{{/if}}{{#unless supportMultipleResponses}}{{#unless returnType}}(){{/unless}}{{{returnType}}}{{/unless}}{{/unless}}, Error<{{{operationIdCamelCase}}}Error>> {
    {{#with allParams.[0]}}
    // add a prefix to parameters to efficiently prevent name collisions
    {{/with}}
    {{#each allParams}}
    let {{{vendorExtensions.x-rust-param-identifier}}} = {{{paramName}}};
    {{/each}}
{{/unless}}

    let uri_str = format!("{}{{{path}}}", configuration.base_path{{#each pathParams}}, {{{baseName}}}={{#if isString}}crate::apis::urlencode({{/if}}{{{vendorExtensions.x-rust-param-identifier}}}{{#unless required}}.unwrap(){{/unless}}{{#if required}}{{#if isNullable}}.unwrap(){{/if}}{{/if}}{{#if isArray}}.join(",").as_ref(){{/if}}{{#unless isString}}{{#unless isUuid}}{{#unless isPrimitiveType}}{{#unless isContainer}}.to_string(){{/unless}}{{/unless}}{{/unless}}{{/unless}}{{#if isString}}){{/if}}{{/each}});
    let mut req_builder = configuration.client.request(reqwest::Method::{{{httpMethod}}}, &uri_str);

    {{#each queryParams}}
    {{#if required}}
    {{#if isArray}}
    req_builder = match "{{collectionFormat}}" {
        "multi" => req_builder.query(&{{{vendorExtensions.x-rust-param-identifier}}}.into_iter().map(|p| ("{{{baseName}}}".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
        _ => req_builder.query(&[("{{{baseName}}}", &{{{vendorExtensions.x-rust-param-identifier}}}.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
    };
    {{/if}}
    {{#unless isArray}}
    {{#unless isNullable}}
    req_builder = req_builder.query(&[("{{{baseName}}}", &{{{vendorExtensions.x-rust-param-identifier}}}.to_string())]);
    {{/unless}}
    {{#if isNullable}}
    {{#if isDeepObject}}
    if let Some(ref param_value) = {{{vendorExtensions.x-rust-param-identifier}}} {
        let params = crate::apis::parse_deep_object("{{{baseName}}}", param_value);
        req_builder = req_builder.query(&params);
    };
    {{/if}}
    {{#unless isDeepObject}}
    if let Some(ref param_value) = {{{vendorExtensions.x-rust-param-identifier}}} {
        req_builder = req_builder.query(&[("{{{baseName}}}", &param_value.to_string())]);
    };
    {{/unless}}
    {{/if}}
    {{/unless}}
    {{/if}}
    {{#unless required}}
    if let Some(ref param_value) = {{{vendorExtensions.x-rust-param-identifier}}} {
        {{#if isArray}}
        req_builder = match "{{collectionFormat}}" {
            "multi" => req_builder.query(&param_value.into_iter().map(|p| ("{{{baseName}}}".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => req_builder.query(&[("{{{baseName}}}", &param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
        {{/if}}
        {{#unless isArray}}
        {{#if isDeepObject}}
        let params = crate::apis::parse_deep_object("{{{baseName}}}", param_value);
        req_builder = req_builder.query(&params);
        {{/if}}
        {{#unless isDeepObject}}
        req_builder = req_builder.query(&[("{{{baseName}}}", &param_value.to_string())]);
        {{/unless}}
        {{/unless}}
    }
    {{/unless}}
    {{/each}}
    {{#if hasAuthMethods}}
    {{#each authMethods}}
    {{#if isApiKey}}
    {{#if isKeyInQuery}}
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.query(&[("{{{keyParamName}}}", value)]);
    }
    {{/if}}
    {{/if}}
    {{/each}}
    {{/if}}
    {{#if hasAuthMethods}}
    {{#if withAWSV4Signature}}
    if let Some(ref aws_v4_key) = configuration.aws_v4_key {
        let new_headers = match aws_v4_key.sign(
	    &uri_str,
	    "{{{httpMethod}}}",
	    {{#if hasBodyParam}}
	    {{#each bodyParams}}
	    &serde_json::to_string(&{{{vendorExtensions.x-rust-param-identifier}}}).expect("param should serialize to string"),
	    {{/each}}
	    {{/if}}
	    {{#unless hasBodyParam}}
	    "",
	    {{/unless}}
	    ) {
	      Ok(new_headers) => new_headers,
	      Err(err) => return Err(Error::AWSV4SignatureError(err)),
	    };
	for (name, value) in new_headers.iter() {
	    req_builder = req_builder.header(name.as_str(), value.as_str());
	}
    }
    {{/if}}
    {{/if}}
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    {{#if hasHeaderParams}}
    {{#each headerParams}}
    {{#if required}}
    {{#unless isNullable}}
    req_builder = req_builder.header("{{{baseName}}}", {{{vendorExtensions.x-rust-param-identifier}}}{{#if isArray}}.join(","){{/if}}.to_string());
    {{/unless}}
    {{#if isNullable}}
    match {{{vendorExtensions.x-rust-param-identifier}}} {
        Some(param_value) => { req_builder = req_builder.header("{{{baseName}}}", param_value{{#if isArray}}.join(","){{/if}}.to_string()); },
        None => { req_builder = req_builder.header("{{{baseName}}}", ""); },
    }
    {{/if}}
    {{/if}}
    {{#unless required}}
    if let Some(param_value) = {{{vendorExtensions.x-rust-param-identifier}}} {
        req_builder = req_builder.header("{{{baseName}}}", param_value{{#if isArray}}.join(","){{/if}}.to_string());
    }
    {{/unless}}
    {{/each}}
    {{/if}}
    {{#if hasAuthMethods}}
    {{#each authMethods}}
    {{#if supportTokenSource}}
    // Obtain a token from source provider.
    // Tokens can be Id or access tokens depending on the provider type and configuration.
    let token = configuration.token_source.token().await.map_err(Error::TokenSource)?;
    // The token format is the responsibility of the provider, thus we just set the authorization header with whatever is given.
    req_builder = req_builder.header(reqwest::header::AUTHORIZATION, token);
    {{/if}}
    {{#unless supportTokenSource}}
    {{#if isApiKey}}
    {{#if isKeyInHeader}}
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("{{{keyParamName}}}", value);
    };
    {{/if}}
    {{/if}}
    {{#if isBasic}}
    {{#if isBasicBasic}}
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    {{/if}}
    {{#if isBasicBearer}}
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    {{/if}}
    {{/if}}
    {{#if isOAuth}}
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    {{/if}}
    {{/unless}}
    {{/each}}
    {{/if}}
    {{#if isMultipart}}
    {{#if hasFormParams}}
    let mut multipart_form = reqwest{{#unless supportAsync}}::blocking{{/unless}}::multipart::Form::new();
    {{#each formParams}}
    {{#if isFile}}
    {{#unless supportAsync}}
    {{#if required}}
    {{#unless isNullable}}
    multipart_form = multipart_form.file("{{{baseName}}}", {{{vendorExtensions.x-rust-param-identifier}}})?;
    {{/unless}}
    {{#if isNullable}}
    match {{{vendorExtensions.x-rust-param-identifier}}} {
        Some(param_value) => { multipart_form = multipart_form.file("{{{baseName}}}", param_value)?; },
        None => { unimplemented!("Required nullable form file param not supported"); },
    }
    {{/if}}
    {{/if}}
    {{#unless required}}
    if let Some(param_value) = {{{vendorExtensions.x-rust-param-identifier}}} {
        multipart_form = multipart_form.file("{{{baseName}}}", param_value)?;
    }
    {{/unless}}
    {{/unless}}
    {{#if supportAsync}}
    // TODO: support file upload for '{{{baseName}}}' parameter
    {{/if}}
    {{/if}}
    {{#unless isFile}}
    {{#if required}}
    {{#unless isNullable}}
    multipart_form = multipart_form.text("{{{baseName}}}", {{{vendorExtensions.x-rust-param-identifier}}}{{#if isArray}}.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(","){{/if}}.to_string());
    {{/unless}}
    {{#if isNullable}}
    match {{{vendorExtensions.x-rust-param-identifier}}} {
        Some(param_value) => { multipart_form = multipart_form.text("{{{baseName}}}", param_value{{#if isArray}}.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(","){{/if}}.to_string()); },
        None => { multipart_form = multipart_form.text("{{{baseName}}}", ""); },
    }
    {{/if}}
    {{/if}}
    {{#unless required}}
    if let Some(param_value) = {{{vendorExtensions.x-rust-param-identifier}}} {
        multipart_form = multipart_form.text("{{{baseName}}}", param_value{{#if isArray}}.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(","){{/if}}.to_string());
    }
    {{/unless}}
    {{/unless}}
    {{/each}}
    req_builder = req_builder.multipart(multipart_form);
    {{/if}}
    {{/if}}
    {{#unless isMultipart}}
    {{#if hasFormParams}}
    let mut multipart_form_params = std::collections::HashMap::new();
    {{#each formParams}}
    {{#if isFile}}
    {{#if required}}
    {{#unless isNullable}}
    multipart_form_params.insert("{{{baseName}}}", unimplemented!("File form param not supported with x-www-form-urlencoded content"));
    {{/unless}}
    {{#if isNullable}}
    match {{{vendorExtensions.x-rust-param-identifier}}} {
        Some(param_value) => { multipart_form_params.insert("{{{baseName}}}", unimplemented!("File form param not supported with x-www-form-urlencoded content")); },
        None => { unimplemented!("Required nullable file form param not supported with x-www-form-urlencoded content"); },
    }
    {{/if}}
    {{/if}}
    {{#unless required}}
    if let Some(param_value) = {{{vendorExtensions.x-rust-param-identifier}}} {
        multipart_form_params.insert("{{{baseName}}}", unimplemented!("File form param not supported with x-www-form-urlencoded content"));
    }
    {{/unless}}
    {{/if}}
    {{#unless isFile}}
    {{#if required}}
    {{#unless isNullable}}
    multipart_form_params.insert("{{{baseName}}}", {{{vendorExtensions.x-rust-param-identifier}}}{{#if isArray}}.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(","){{/if}}.to_string());
    {{/unless}}
    {{#if isNullable}}
    match {{{vendorExtensions.x-rust-param-identifier}}} {
        Some(param_value) => { multipart_form_params.insert("{{{baseName}}}", param_value{{#if isArray}}.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(","){{/if}}.to_string()); },
        None => { multipart_form_params.insert("{{{baseName}}}", ""); },
    }
    {{/if}}
    {{/if}}
    {{#unless required}}
    if let Some(param_value) = {{{vendorExtensions.x-rust-param-identifier}}} {
        multipart_form_params.insert("{{{baseName}}}", param_value{{#if isArray}}.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(","){{/if}}.to_string());
    }
    {{/unless}}
    {{/unless}}
    {{/each}}
    req_builder = req_builder.form(&multipart_form_params);
    {{/if}}
    {{/unless}}
    {{#if hasBodyParam}}
    {{#each bodyParams}}
    {{#if isFile}}
    req_builder = req_builder.body({{{vendorExtensions.x-rust-param-identifier}}});
    {{/if}}
    {{#unless isFile}}
    req_builder = req_builder.json(&{{{vendorExtensions.x-rust-param-identifier}}});
    {{/unless}}
    {{/each}}
    {{/if}}

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req){{#if supportAsync}}.await{{/if}}?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        {{#unless supportMultipleResponses}}
        {{#if isResponseFile}}
        Ok(resp)
        {{/if}}
        {{#unless isResponseFile}}
        {{#unless returnType}}
        Ok(())
        {{/unless}}
        {{#if returnType}}
        let content = resp.text(){{#if supportAsync}}.await{{/if}}?;
        serde_json::from_str(&content).map_err(Error::from)
        {{/if}}
        {{/unless}}
        {{/unless}}
        {{#if supportMultipleResponses}}
        {{#if isResponseFile}}
        Ok(resp)
        {{/if}}
        {{#unless isResponseFile}}
        let content = resp.text(){{#if supportAsync}}.await{{/if}}?;
        let entity: Option<{{{operationIdCamelCase}}}Success> = serde_json::from_str(&content).ok();
        Ok(ResponseContent { status, content, entity })
        {{/unless}}
        {{/if}}
    } else {
        let content = resp.text(){{#if supportAsync}}.await{{/if}}?;
        let entity: Option<{{{operationIdCamelCase}}}Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

{{/each}}
{{/with}}
