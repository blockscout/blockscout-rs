/*

* BlockScout API
*


* API for BlockScout web app
*

* The version of the OpenAPI document: 1.0.0
* Contact: lymarenko.lev@blockscout.com
* Generated by: https://openapi-generator.tech
*/

use async_trait::async_trait;

#[cfg(feature = "mockall")]
use mockall::automock;

use super::{configuration, Error};
use crate::{apis::ResponseContent, models};
use reqwest;
use serde::{Deserialize, Serialize};
use std::sync::Arc;

#[cfg_attr(feature = "mockall", automock)]
#[async_trait]
pub trait TokensApi: Send + Sync {
    /// GET /api/v2/tokens/{address_hash}/instances/{id}

    ///
    ///

    async fn get_nft_instance(
        &self,
        params: GetNftInstanceParams,
    ) -> Result<ResponseContent<GetNftInstanceSuccess>, Error<GetNftInstanceError>>;

    /// GET /api/v2/tokens/{address_hash}/instances/{id}/transfers

    ///
    ///

    async fn get_nft_instance_transfers(
        &self,
        params: GetNftInstanceTransfersParams,
    ) -> Result<ResponseContent<GetNftInstanceTransfersSuccess>, Error<GetNftInstanceTransfersError>>;

    /// GET /api/v2/tokens/{address_hash}/instances/{id}/transfers-count

    ///
    ///

    async fn get_nft_instance_transfers_count(
        &self,
        params: GetNftInstanceTransfersCountParams,
    ) -> Result<
        ResponseContent<GetNftInstanceTransfersCountSuccess>,
        Error<GetNftInstanceTransfersCountError>,
    >;

    /// GET /api/v2/tokens/{address_hash}/instances

    ///
    ///

    async fn get_nft_instances(
        &self,
        params: GetNftInstancesParams,
    ) -> Result<ResponseContent<GetNftInstancesSuccess>, Error<GetNftInstancesError>>;

    /// GET /api/v2/tokens/{address_hash}

    ///
    ///

    async fn get_token(
        &self,
        params: GetTokenParams,
    ) -> Result<ResponseContent<GetTokenSuccess>, Error<GetTokenError>>;

    /// GET /api/v2/tokens/{address_hash}/counters

    ///
    ///

    async fn get_token_counters(
        &self,
        params: GetTokenCountersParams,
    ) -> Result<ResponseContent<GetTokenCountersSuccess>, Error<GetTokenCountersError>>;

    /// GET /api/v2/tokens/{address_hash}/holders

    ///
    ///

    async fn get_token_holders(
        &self,
        params: GetTokenHoldersParams,
    ) -> Result<ResponseContent<GetTokenHoldersSuccess>, Error<GetTokenHoldersError>>;

    /// GET /api/v2/tokens/{address_hash}/instances/{id}/holders

    ///
    ///

    async fn get_token_instance_holders(
        &self,
        params: GetTokenInstanceHoldersParams,
    ) -> Result<ResponseContent<GetTokenInstanceHoldersSuccess>, Error<GetTokenInstanceHoldersError>>;

    /// GET /api/v2/tokens/{address_hash}/transfers

    ///
    ///

    async fn get_token_token_transfers(
        &self,
        params: GetTokenTokenTransfersParams,
    ) -> Result<ResponseContent<GetTokenTokenTransfersSuccess>, Error<GetTokenTokenTransfersError>>;

    /// GET /api/v2/tokens

    ///
    ///

    async fn get_tokens_list(
        &self,
        params: GetTokensListParams,
    ) -> Result<ResponseContent<GetTokensListSuccess>, Error<GetTokensListError>>;

    /// PATCH /api/v2/tokens/{address_hash}/instances/{id}/refetch-metadata

    ///
    ///

    async fn refetch_token_instance_metadata(
        &self,
        params: RefetchTokenInstanceMetadataParams,
    ) -> Result<
        ResponseContent<RefetchTokenInstanceMetadataSuccess>,
        Error<RefetchTokenInstanceMetadataError>,
    >;
}

pub struct TokensApiClient {
    configuration: Arc<configuration::Configuration>,
}

impl TokensApiClient {
    pub fn new(configuration: Arc<configuration::Configuration>) -> Self {
        Self { configuration }
    }
}

/// struct for passing parameters to the method [`get_nft_instance`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]

pub struct GetNftInstanceParams {
    /// Address hash
    pub address_hash: String,

    /// integer id
    pub id: String,
}

/// struct for passing parameters to the method [`get_nft_instance_transfers`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]

pub struct GetNftInstanceTransfersParams {
    /// Address hash
    pub address_hash: String,

    /// integer id
    pub id: String,
}

/// struct for passing parameters to the method [`get_nft_instance_transfers_count`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]

pub struct GetNftInstanceTransfersCountParams {
    /// Address hash
    pub address_hash: String,

    /// integer id
    pub id: String,
}

/// struct for passing parameters to the method [`get_nft_instances`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]

pub struct GetNftInstancesParams {
    /// Address hash
    pub address_hash: String,
}

/// struct for passing parameters to the method [`get_token`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]

pub struct GetTokenParams {
    /// Address hash
    pub address_hash: String,
}

/// struct for passing parameters to the method [`get_token_counters`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]

pub struct GetTokenCountersParams {
    /// Address hash
    pub address_hash: String,
}

/// struct for passing parameters to the method [`get_token_holders`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]

pub struct GetTokenHoldersParams {
    /// Address hash
    pub address_hash: String,
}

/// struct for passing parameters to the method [`get_token_instance_holders`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]

pub struct GetTokenInstanceHoldersParams {
    /// Address hash
    pub address_hash: String,

    /// integer id
    pub id: String,
}

/// struct for passing parameters to the method [`get_token_token_transfers`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]

pub struct GetTokenTokenTransfersParams {
    /// Address hash
    pub address_hash: String,
}

/// struct for passing parameters to the method [`get_tokens_list`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]

pub struct GetTokensListParams {
    pub q: Option<String>,

    pub r#type: Option<String>,
}

/// struct for passing parameters to the method [`refetch_token_instance_metadata`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]

pub struct RefetchTokenInstanceMetadataParams {
    /// Address hash
    pub address_hash: String,

    /// integer id
    pub id: String,

    pub recaptcha_body: models::RecaptchaBody,
}

#[async_trait]
impl TokensApi for TokensApiClient {
    async fn get_nft_instance(
        &self,
        params: GetNftInstanceParams,
    ) -> Result<ResponseContent<GetNftInstanceSuccess>, Error<GetNftInstanceError>> {
        let GetNftInstanceParams { address_hash, id } = params;

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}/api/v2/tokens/{address_hash}/instances/{id}",
            local_var_configuration.base_path,
            address_hash = crate::apis::urlencode(address_hash),
            id = crate::apis::urlencode(id)
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder
                .header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            let local_var_entity: Option<GetNftInstanceSuccess> =
                serde_json::from_str(&local_var_content).ok();
            let local_var_result = ResponseContent {
                status: local_var_status,
                content: local_var_content,
                entity: local_var_entity,
            };
            Ok(local_var_result)
        } else {
            let local_var_entity: Option<GetNftInstanceError> =
                serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
                entity: local_var_entity,
            };
            Err(Error::ResponseError(local_var_error))
        }
    }

    async fn get_nft_instance_transfers(
        &self,
        params: GetNftInstanceTransfersParams,
    ) -> Result<ResponseContent<GetNftInstanceTransfersSuccess>, Error<GetNftInstanceTransfersError>>
    {
        let GetNftInstanceTransfersParams { address_hash, id } = params;

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}/api/v2/tokens/{address_hash}/instances/{id}/transfers",
            local_var_configuration.base_path,
            address_hash = crate::apis::urlencode(address_hash),
            id = crate::apis::urlencode(id)
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder
                .header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            let local_var_entity: Option<GetNftInstanceTransfersSuccess> =
                serde_json::from_str(&local_var_content).ok();
            let local_var_result = ResponseContent {
                status: local_var_status,
                content: local_var_content,
                entity: local_var_entity,
            };
            Ok(local_var_result)
        } else {
            let local_var_entity: Option<GetNftInstanceTransfersError> =
                serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
                entity: local_var_entity,
            };
            Err(Error::ResponseError(local_var_error))
        }
    }

    async fn get_nft_instance_transfers_count(
        &self,
        params: GetNftInstanceTransfersCountParams,
    ) -> Result<
        ResponseContent<GetNftInstanceTransfersCountSuccess>,
        Error<GetNftInstanceTransfersCountError>,
    > {
        let GetNftInstanceTransfersCountParams { address_hash, id } = params;

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}/api/v2/tokens/{address_hash}/instances/{id}/transfers-count",
            local_var_configuration.base_path,
            address_hash = crate::apis::urlencode(address_hash),
            id = crate::apis::urlencode(id)
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder
                .header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            let local_var_entity: Option<GetNftInstanceTransfersCountSuccess> =
                serde_json::from_str(&local_var_content).ok();
            let local_var_result = ResponseContent {
                status: local_var_status,
                content: local_var_content,
                entity: local_var_entity,
            };
            Ok(local_var_result)
        } else {
            let local_var_entity: Option<GetNftInstanceTransfersCountError> =
                serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
                entity: local_var_entity,
            };
            Err(Error::ResponseError(local_var_error))
        }
    }

    async fn get_nft_instances(
        &self,
        params: GetNftInstancesParams,
    ) -> Result<ResponseContent<GetNftInstancesSuccess>, Error<GetNftInstancesError>> {
        let GetNftInstancesParams { address_hash } = params;

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}/api/v2/tokens/{address_hash}/instances",
            local_var_configuration.base_path,
            address_hash = crate::apis::urlencode(address_hash)
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder
                .header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            let local_var_entity: Option<GetNftInstancesSuccess> =
                serde_json::from_str(&local_var_content).ok();
            let local_var_result = ResponseContent {
                status: local_var_status,
                content: local_var_content,
                entity: local_var_entity,
            };
            Ok(local_var_result)
        } else {
            let local_var_entity: Option<GetNftInstancesError> =
                serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
                entity: local_var_entity,
            };
            Err(Error::ResponseError(local_var_error))
        }
    }

    async fn get_token(
        &self,
        params: GetTokenParams,
    ) -> Result<ResponseContent<GetTokenSuccess>, Error<GetTokenError>> {
        let GetTokenParams { address_hash } = params;

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}/api/v2/tokens/{address_hash}",
            local_var_configuration.base_path,
            address_hash = crate::apis::urlencode(address_hash)
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder
                .header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            let local_var_entity: Option<GetTokenSuccess> =
                serde_json::from_str(&local_var_content).ok();
            let local_var_result = ResponseContent {
                status: local_var_status,
                content: local_var_content,
                entity: local_var_entity,
            };
            Ok(local_var_result)
        } else {
            let local_var_entity: Option<GetTokenError> =
                serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
                entity: local_var_entity,
            };
            Err(Error::ResponseError(local_var_error))
        }
    }

    async fn get_token_counters(
        &self,
        params: GetTokenCountersParams,
    ) -> Result<ResponseContent<GetTokenCountersSuccess>, Error<GetTokenCountersError>> {
        let GetTokenCountersParams { address_hash } = params;

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}/api/v2/tokens/{address_hash}/counters",
            local_var_configuration.base_path,
            address_hash = crate::apis::urlencode(address_hash)
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder
                .header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            let local_var_entity: Option<GetTokenCountersSuccess> =
                serde_json::from_str(&local_var_content).ok();
            let local_var_result = ResponseContent {
                status: local_var_status,
                content: local_var_content,
                entity: local_var_entity,
            };
            Ok(local_var_result)
        } else {
            let local_var_entity: Option<GetTokenCountersError> =
                serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
                entity: local_var_entity,
            };
            Err(Error::ResponseError(local_var_error))
        }
    }

    async fn get_token_holders(
        &self,
        params: GetTokenHoldersParams,
    ) -> Result<ResponseContent<GetTokenHoldersSuccess>, Error<GetTokenHoldersError>> {
        let GetTokenHoldersParams { address_hash } = params;

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}/api/v2/tokens/{address_hash}/holders",
            local_var_configuration.base_path,
            address_hash = crate::apis::urlencode(address_hash)
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder
                .header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            let local_var_entity: Option<GetTokenHoldersSuccess> =
                serde_json::from_str(&local_var_content).ok();
            let local_var_result = ResponseContent {
                status: local_var_status,
                content: local_var_content,
                entity: local_var_entity,
            };
            Ok(local_var_result)
        } else {
            let local_var_entity: Option<GetTokenHoldersError> =
                serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
                entity: local_var_entity,
            };
            Err(Error::ResponseError(local_var_error))
        }
    }

    async fn get_token_instance_holders(
        &self,
        params: GetTokenInstanceHoldersParams,
    ) -> Result<ResponseContent<GetTokenInstanceHoldersSuccess>, Error<GetTokenInstanceHoldersError>>
    {
        let GetTokenInstanceHoldersParams { address_hash, id } = params;

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}/api/v2/tokens/{address_hash}/instances/{id}/holders",
            local_var_configuration.base_path,
            address_hash = crate::apis::urlencode(address_hash),
            id = crate::apis::urlencode(id)
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder
                .header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            let local_var_entity: Option<GetTokenInstanceHoldersSuccess> =
                serde_json::from_str(&local_var_content).ok();
            let local_var_result = ResponseContent {
                status: local_var_status,
                content: local_var_content,
                entity: local_var_entity,
            };
            Ok(local_var_result)
        } else {
            let local_var_entity: Option<GetTokenInstanceHoldersError> =
                serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
                entity: local_var_entity,
            };
            Err(Error::ResponseError(local_var_error))
        }
    }

    async fn get_token_token_transfers(
        &self,
        params: GetTokenTokenTransfersParams,
    ) -> Result<ResponseContent<GetTokenTokenTransfersSuccess>, Error<GetTokenTokenTransfersError>>
    {
        let GetTokenTokenTransfersParams { address_hash } = params;

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}/api/v2/tokens/{address_hash}/transfers",
            local_var_configuration.base_path,
            address_hash = crate::apis::urlencode(address_hash)
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder
                .header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            let local_var_entity: Option<GetTokenTokenTransfersSuccess> =
                serde_json::from_str(&local_var_content).ok();
            let local_var_result = ResponseContent {
                status: local_var_status,
                content: local_var_content,
                entity: local_var_entity,
            };
            Ok(local_var_result)
        } else {
            let local_var_entity: Option<GetTokenTokenTransfersError> =
                serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
                entity: local_var_entity,
            };
            Err(Error::ResponseError(local_var_error))
        }
    }

    async fn get_tokens_list(
        &self,
        params: GetTokensListParams,
    ) -> Result<ResponseContent<GetTokensListSuccess>, Error<GetTokensListError>> {
        let GetTokensListParams { q, r#type } = params;

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!("{}/api/v2/tokens", local_var_configuration.base_path);
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

        if let Some(ref local_var_str) = q {
            local_var_req_builder =
                local_var_req_builder.query(&[("q", &local_var_str.to_string())]);
        }

        if let Some(ref local_var_str) = r#type {
            local_var_req_builder =
                local_var_req_builder.query(&[("type", &local_var_str.to_string())]);
        }

        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder
                .header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            let local_var_entity: Option<GetTokensListSuccess> =
                serde_json::from_str(&local_var_content).ok();
            let local_var_result = ResponseContent {
                status: local_var_status,
                content: local_var_content,
                entity: local_var_entity,
            };
            Ok(local_var_result)
        } else {
            let local_var_entity: Option<GetTokensListError> =
                serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
                entity: local_var_entity,
            };
            Err(Error::ResponseError(local_var_error))
        }
    }

    async fn refetch_token_instance_metadata(
        &self,
        params: RefetchTokenInstanceMetadataParams,
    ) -> Result<
        ResponseContent<RefetchTokenInstanceMetadataSuccess>,
        Error<RefetchTokenInstanceMetadataError>,
    > {
        let RefetchTokenInstanceMetadataParams {
            address_hash,

            id,

            recaptcha_body,
        } = params;

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}/api/v2/tokens/{address_hash}/instances/{id}/refetch-metadata",
            local_var_configuration.base_path,
            address_hash = crate::apis::urlencode(address_hash),
            id = crate::apis::urlencode(id)
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder
                .header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }

        local_var_req_builder = local_var_req_builder.json(&recaptcha_body);

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            let local_var_entity: Option<RefetchTokenInstanceMetadataSuccess> =
                serde_json::from_str(&local_var_content).ok();
            let local_var_result = ResponseContent {
                status: local_var_status,
                content: local_var_content,
                entity: local_var_entity,
            };
            Ok(local_var_result)
        } else {
            let local_var_entity: Option<RefetchTokenInstanceMetadataError> =
                serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
                entity: local_var_entity,
            };
            Err(Error::ResponseError(local_var_error))
        }
    }
}

/// struct for typed successes of method [`get_nft_instance`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetNftInstanceSuccess {
    Status200(models::NftInstance),

    UnknownValue(serde_json::Value),
}

// changed
impl ResponseContent<GetNftInstanceSuccess> {
    pub fn try_as_success(&self) -> Option<&models::NftInstance> {
        match &self.entity {
            Some(GetNftInstanceSuccess::Status200(data)) => Some(data),
            _ => None,
        }
    }

    pub fn try_parse_as_success_model(
        &self,
    ) -> Result<models::NftInstance, serde_json_path_to_error::Error> {
        serde_json_path_to_error::from_str(&self.content)
    }
}

/// struct for typed successes of method [`get_nft_instance_transfers`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetNftInstanceTransfersSuccess {
    Status200(models::GetNftInstanceTransfers200Response),

    UnknownValue(serde_json::Value),
}

// changed
impl ResponseContent<GetNftInstanceTransfersSuccess> {
    pub fn try_as_success(&self) -> Option<&models::GetNftInstanceTransfers200Response> {
        match &self.entity {
            Some(GetNftInstanceTransfersSuccess::Status200(data)) => Some(data),
            _ => None,
        }
    }

    pub fn try_parse_as_success_model(
        &self,
    ) -> Result<models::GetNftInstanceTransfers200Response, serde_json_path_to_error::Error> {
        serde_json_path_to_error::from_str(&self.content)
    }
}

/// struct for typed successes of method [`get_nft_instance_transfers_count`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetNftInstanceTransfersCountSuccess {
    Status200(models::GetNftInstanceTransfersCount200Response),

    UnknownValue(serde_json::Value),
}

// changed
impl ResponseContent<GetNftInstanceTransfersCountSuccess> {
    pub fn try_as_success(&self) -> Option<&models::GetNftInstanceTransfersCount200Response> {
        match &self.entity {
            Some(GetNftInstanceTransfersCountSuccess::Status200(data)) => Some(data),
            _ => None,
        }
    }

    pub fn try_parse_as_success_model(
        &self,
    ) -> Result<models::GetNftInstanceTransfersCount200Response, serde_json_path_to_error::Error>
    {
        serde_json_path_to_error::from_str(&self.content)
    }
}

/// struct for typed successes of method [`get_nft_instances`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetNftInstancesSuccess {
    Status200(models::GetNftInstances200Response),

    UnknownValue(serde_json::Value),
}

// changed
impl ResponseContent<GetNftInstancesSuccess> {
    pub fn try_as_success(&self) -> Option<&models::GetNftInstances200Response> {
        match &self.entity {
            Some(GetNftInstancesSuccess::Status200(data)) => Some(data),
            _ => None,
        }
    }

    pub fn try_parse_as_success_model(
        &self,
    ) -> Result<models::GetNftInstances200Response, serde_json_path_to_error::Error> {
        serde_json_path_to_error::from_str(&self.content)
    }
}

/// struct for typed successes of method [`get_token`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTokenSuccess {
    Status200(models::TokenInfo),

    UnknownValue(serde_json::Value),
}

// changed
impl ResponseContent<GetTokenSuccess> {
    pub fn try_as_success(&self) -> Option<&models::TokenInfo> {
        match &self.entity {
            Some(GetTokenSuccess::Status200(data)) => Some(data),
            _ => None,
        }
    }

    pub fn try_parse_as_success_model(
        &self,
    ) -> Result<models::TokenInfo, serde_json_path_to_error::Error> {
        serde_json_path_to_error::from_str(&self.content)
    }
}

/// struct for typed successes of method [`get_token_counters`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTokenCountersSuccess {
    Status200(models::TokenCounters),

    UnknownValue(serde_json::Value),
}

// changed
impl ResponseContent<GetTokenCountersSuccess> {
    pub fn try_as_success(&self) -> Option<&models::TokenCounters> {
        match &self.entity {
            Some(GetTokenCountersSuccess::Status200(data)) => Some(data),
            _ => None,
        }
    }

    pub fn try_parse_as_success_model(
        &self,
    ) -> Result<models::TokenCounters, serde_json_path_to_error::Error> {
        serde_json_path_to_error::from_str(&self.content)
    }
}

/// struct for typed successes of method [`get_token_holders`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTokenHoldersSuccess {
    Status200(models::GetTokenHolders200Response),

    UnknownValue(serde_json::Value),
}

// changed
impl ResponseContent<GetTokenHoldersSuccess> {
    pub fn try_as_success(&self) -> Option<&models::GetTokenHolders200Response> {
        match &self.entity {
            Some(GetTokenHoldersSuccess::Status200(data)) => Some(data),
            _ => None,
        }
    }

    pub fn try_parse_as_success_model(
        &self,
    ) -> Result<models::GetTokenHolders200Response, serde_json_path_to_error::Error> {
        serde_json_path_to_error::from_str(&self.content)
    }
}

/// struct for typed successes of method [`get_token_instance_holders`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTokenInstanceHoldersSuccess {
    Status200(models::GetTokenInstanceHolders200Response),

    UnknownValue(serde_json::Value),
}

// changed
impl ResponseContent<GetTokenInstanceHoldersSuccess> {
    pub fn try_as_success(&self) -> Option<&models::GetTokenInstanceHolders200Response> {
        match &self.entity {
            Some(GetTokenInstanceHoldersSuccess::Status200(data)) => Some(data),
            _ => None,
        }
    }

    pub fn try_parse_as_success_model(
        &self,
    ) -> Result<models::GetTokenInstanceHolders200Response, serde_json_path_to_error::Error> {
        serde_json_path_to_error::from_str(&self.content)
    }
}

/// struct for typed successes of method [`get_token_token_transfers`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTokenTokenTransfersSuccess {
    Status200(models::GetTokenTokenTransfers200Response),

    UnknownValue(serde_json::Value),
}

// changed
impl ResponseContent<GetTokenTokenTransfersSuccess> {
    pub fn try_as_success(&self) -> Option<&models::GetTokenTokenTransfers200Response> {
        match &self.entity {
            Some(GetTokenTokenTransfersSuccess::Status200(data)) => Some(data),
            _ => None,
        }
    }

    pub fn try_parse_as_success_model(
        &self,
    ) -> Result<models::GetTokenTokenTransfers200Response, serde_json_path_to_error::Error> {
        serde_json_path_to_error::from_str(&self.content)
    }
}

/// struct for typed successes of method [`get_tokens_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTokensListSuccess {
    Status200(models::GetTokensList200Response),

    UnknownValue(serde_json::Value),
}

// changed
impl ResponseContent<GetTokensListSuccess> {
    pub fn try_as_success(&self) -> Option<&models::GetTokensList200Response> {
        match &self.entity {
            Some(GetTokensListSuccess::Status200(data)) => Some(data),
            _ => None,
        }
    }

    pub fn try_parse_as_success_model(
        &self,
    ) -> Result<models::GetTokensList200Response, serde_json_path_to_error::Error> {
        serde_json_path_to_error::from_str(&self.content)
    }
}

/// struct for typed successes of method [`refetch_token_instance_metadata`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RefetchTokenInstanceMetadataSuccess {
    Status200(models::RefetchTokenInstanceMetadata200Response),

    UnknownValue(serde_json::Value),
}

// changed
impl ResponseContent<RefetchTokenInstanceMetadataSuccess> {
    pub fn try_as_success(&self) -> Option<&models::RefetchTokenInstanceMetadata200Response> {
        match &self.entity {
            Some(RefetchTokenInstanceMetadataSuccess::Status200(data)) => Some(data),
            _ => None,
        }
    }

    pub fn try_parse_as_success_model(
        &self,
    ) -> Result<models::RefetchTokenInstanceMetadata200Response, serde_json_path_to_error::Error>
    {
        serde_json_path_to_error::from_str(&self.content)
    }
}

/// struct for typed errors of method [`get_nft_instance`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetNftInstanceError {
    Status400(),

    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_nft_instance_transfers`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetNftInstanceTransfersError {
    Status400(),

    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_nft_instance_transfers_count`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetNftInstanceTransfersCountError {
    Status400(),

    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_nft_instances`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetNftInstancesError {
    Status400(),

    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_token`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTokenError {
    Status400(),

    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_token_counters`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTokenCountersError {
    Status400(),

    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_token_holders`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTokenHoldersError {
    Status400(),

    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_token_instance_holders`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTokenInstanceHoldersError {
    Status400(),

    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_token_token_transfers`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTokenTokenTransfersError {
    Status400(),

    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_tokens_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTokensListError {
    Status400(),

    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`refetch_token_instance_metadata`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RefetchTokenInstanceMetadataError {
    Status403(models::RefetchTokenInstanceMetadata403Response),

    UnknownValue(serde_json::Value),
}
