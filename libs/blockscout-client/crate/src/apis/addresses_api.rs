/*

* BlockScout API
*


* API for BlockScout web app
*

* The version of the OpenAPI document: 1.0.0
* Contact: lymarenko.lev@blockscout.com
* Generated by: https://openapi-generator.tech
*/

use async_trait::async_trait;

#[cfg(feature = "mockall")]
use mockall::automock;

use super::{configuration, Error};
use crate::{apis::ResponseContent, models};
use reqwest;
use serde::{Deserialize, Serialize};
use std::sync::Arc;

#[cfg_attr(feature = "mockall", automock)]
#[async_trait]
pub trait AddressesApi: Send + Sync {
    /// GET /api/v2/addresses/{address_hash}

    ///
    ///

    async fn get_address(
        &self,
        params: GetAddressParams,
    ) -> Result<ResponseContent<GetAddressSuccess>, Error<GetAddressError>>;

    /// GET /api/v2/addresses/{address_hash}/blocks-validated

    ///
    ///

    async fn get_address_blocks_validated(
        &self,
        params: GetAddressBlocksValidatedParams,
    ) -> Result<
        ResponseContent<GetAddressBlocksValidatedSuccess>,
        Error<GetAddressBlocksValidatedError>,
    >;

    /// GET /api/v2/addresses/{address_hash}/coin-balance-history

    ///
    ///

    async fn get_address_coin_balance_history(
        &self,
        params: GetAddressCoinBalanceHistoryParams,
    ) -> Result<
        ResponseContent<GetAddressCoinBalanceHistorySuccess>,
        Error<GetAddressCoinBalanceHistoryError>,
    >;

    /// GET /api/v2/addresses/{address_hash}/coin-balance-history-by-day

    ///
    ///

    async fn get_address_coin_balance_history_by_day(
        &self,
        params: GetAddressCoinBalanceHistoryByDayParams,
    ) -> Result<
        ResponseContent<GetAddressCoinBalanceHistoryByDaySuccess>,
        Error<GetAddressCoinBalanceHistoryByDayError>,
    >;

    /// GET /api/v2/addresses/{address_hash}/counters

    ///
    ///

    async fn get_address_counters(
        &self,
        params: GetAddressCountersParams,
    ) -> Result<ResponseContent<GetAddressCountersSuccess>, Error<GetAddressCountersError>>;

    /// GET /api/v2/addresses/{address_hash}/internal-transactions

    ///
    ///

    async fn get_address_internal_txs(
        &self,
        params: GetAddressInternalTxsParams,
    ) -> Result<ResponseContent<GetAddressInternalTxsSuccess>, Error<GetAddressInternalTxsError>>;

    /// GET /api/v2/addresses/{address_hash}/logs

    ///
    ///

    async fn get_address_logs(
        &self,
        params: GetAddressLogsParams,
    ) -> Result<ResponseContent<GetAddressLogsSuccess>, Error<GetAddressLogsError>>;

    /// GET /api/v2/addresses/{address_hash}/nft

    ///
    ///

    async fn get_address_nft(
        &self,
        params: GetAddressNftParams,
    ) -> Result<ResponseContent<GetAddressNftSuccess>, Error<GetAddressNftError>>;

    /// GET /api/v2/addresses/{address_hash}/nft/collections

    ///
    ///

    async fn get_address_nft_collections(
        &self,
        params: GetAddressNftCollectionsParams,
    ) -> Result<
        ResponseContent<GetAddressNftCollectionsSuccess>,
        Error<GetAddressNftCollectionsError>,
    >;

    /// GET /api/v2/addresses/{address_hash}/token-balances

    ///
    ///

    async fn get_address_token_balances(
        &self,
        params: GetAddressTokenBalancesParams,
    ) -> Result<ResponseContent<GetAddressTokenBalancesSuccess>, Error<GetAddressTokenBalancesError>>;

    /// GET /api/v2/addresses/{address_hash}/token-transfers

    ///
    ///

    async fn get_address_token_transfers(
        &self,
        params: GetAddressTokenTransfersParams,
    ) -> Result<
        ResponseContent<GetAddressTokenTransfersSuccess>,
        Error<GetAddressTokenTransfersError>,
    >;

    /// GET /api/v2/addresses/{address_hash}/tokens

    ///
    ///

    async fn get_address_tokens(
        &self,
        params: GetAddressTokensParams,
    ) -> Result<ResponseContent<GetAddressTokensSuccess>, Error<GetAddressTokensError>>;

    /// GET /api/v2/addresses/{address_hash}/transactions

    ///
    ///

    async fn get_address_txs(
        &self,
        params: GetAddressTxsParams,
    ) -> Result<ResponseContent<GetAddressTxsSuccess>, Error<GetAddressTxsError>>;

    /// GET /api/v2/addresses/{address_hash}/withdrawals

    ///
    ///

    async fn get_address_withdrawals(
        &self,
        params: GetAddressWithdrawalsParams,
    ) -> Result<ResponseContent<GetAddressWithdrawalsSuccess>, Error<GetAddressWithdrawalsError>>;

    /// GET /api/v2/addresses

    ///
    ///

    async fn get_addresses(
        &self,
    ) -> Result<ResponseContent<GetAddressesSuccess>, Error<GetAddressesError>>;
}

pub struct AddressesApiClient {
    configuration: Arc<configuration::Configuration>,
}

impl AddressesApiClient {
    pub fn new(configuration: Arc<configuration::Configuration>) -> Self {
        Self { configuration }
    }
}

/// struct for passing parameters to the method [`get_address`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]

pub struct GetAddressParams {
    /// Address hash
    pub address_hash: String,
}

/// struct for passing parameters to the method [`get_address_blocks_validated`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]

pub struct GetAddressBlocksValidatedParams {
    /// Address hash
    pub address_hash: String,
}

/// struct for passing parameters to the method [`get_address_coin_balance_history`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]

pub struct GetAddressCoinBalanceHistoryParams {
    /// Address hash
    pub address_hash: String,
}

/// struct for passing parameters to the method [`get_address_coin_balance_history_by_day`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]

pub struct GetAddressCoinBalanceHistoryByDayParams {
    /// Address hash
    pub address_hash: String,
}

/// struct for passing parameters to the method [`get_address_counters`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]

pub struct GetAddressCountersParams {
    /// Address hash
    pub address_hash: String,
}

/// struct for passing parameters to the method [`get_address_internal_txs`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]

pub struct GetAddressInternalTxsParams {
    /// Address hash
    pub address_hash: String,

    pub filter: Option<String>,
}

/// struct for passing parameters to the method [`get_address_logs`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]

pub struct GetAddressLogsParams {
    /// Address hash
    pub address_hash: String,
}

/// struct for passing parameters to the method [`get_address_nft`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]

pub struct GetAddressNftParams {
    /// Address hash
    pub address_hash: String,

    pub r#type: Option<String>,
}

/// struct for passing parameters to the method [`get_address_nft_collections`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]

pub struct GetAddressNftCollectionsParams {
    /// Address hash
    pub address_hash: String,

    pub r#type: Option<String>,
}

/// struct for passing parameters to the method [`get_address_token_balances`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]

pub struct GetAddressTokenBalancesParams {
    /// Address hash
    pub address_hash: String,
}

/// struct for passing parameters to the method [`get_address_token_transfers`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]

pub struct GetAddressTokenTransfersParams {
    /// Address hash
    pub address_hash: String,

    pub r#type: Option<String>,

    pub filter: Option<String>,

    pub token: Option<String>,
}

/// struct for passing parameters to the method [`get_address_tokens`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]

pub struct GetAddressTokensParams {
    /// Address hash
    pub address_hash: String,

    pub r#type: Option<String>,
}

/// struct for passing parameters to the method [`get_address_txs`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]

pub struct GetAddressTxsParams {
    /// Address hash
    pub address_hash: String,

    pub filter: Option<String>,
}

/// struct for passing parameters to the method [`get_address_withdrawals`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]

pub struct GetAddressWithdrawalsParams {
    /// Address hash
    pub address_hash: String,
}

#[async_trait]
impl AddressesApi for AddressesApiClient {
    async fn get_address(
        &self,
        params: GetAddressParams,
    ) -> Result<ResponseContent<GetAddressSuccess>, Error<GetAddressError>> {
        let GetAddressParams { address_hash } = params;

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}/api/v2/addresses/{address_hash}",
            local_var_configuration.base_path,
            address_hash = crate::apis::urlencode(address_hash)
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder
                .header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            let local_var_entity: Option<GetAddressSuccess> =
                serde_json::from_str(&local_var_content).ok();
            let local_var_result = ResponseContent {
                status: local_var_status,
                content: local_var_content,
                entity: local_var_entity,
            };
            Ok(local_var_result)
        } else {
            let local_var_entity: Option<GetAddressError> =
                serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
                entity: local_var_entity,
            };
            Err(Error::ResponseError(local_var_error))
        }
    }

    async fn get_address_blocks_validated(
        &self,
        params: GetAddressBlocksValidatedParams,
    ) -> Result<
        ResponseContent<GetAddressBlocksValidatedSuccess>,
        Error<GetAddressBlocksValidatedError>,
    > {
        let GetAddressBlocksValidatedParams { address_hash } = params;

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}/api/v2/addresses/{address_hash}/blocks-validated",
            local_var_configuration.base_path,
            address_hash = crate::apis::urlencode(address_hash)
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder
                .header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            let local_var_entity: Option<GetAddressBlocksValidatedSuccess> =
                serde_json::from_str(&local_var_content).ok();
            let local_var_result = ResponseContent {
                status: local_var_status,
                content: local_var_content,
                entity: local_var_entity,
            };
            Ok(local_var_result)
        } else {
            let local_var_entity: Option<GetAddressBlocksValidatedError> =
                serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
                entity: local_var_entity,
            };
            Err(Error::ResponseError(local_var_error))
        }
    }

    async fn get_address_coin_balance_history(
        &self,
        params: GetAddressCoinBalanceHistoryParams,
    ) -> Result<
        ResponseContent<GetAddressCoinBalanceHistorySuccess>,
        Error<GetAddressCoinBalanceHistoryError>,
    > {
        let GetAddressCoinBalanceHistoryParams { address_hash } = params;

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}/api/v2/addresses/{address_hash}/coin-balance-history",
            local_var_configuration.base_path,
            address_hash = crate::apis::urlencode(address_hash)
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder
                .header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            let local_var_entity: Option<GetAddressCoinBalanceHistorySuccess> =
                serde_json::from_str(&local_var_content).ok();
            let local_var_result = ResponseContent {
                status: local_var_status,
                content: local_var_content,
                entity: local_var_entity,
            };
            Ok(local_var_result)
        } else {
            let local_var_entity: Option<GetAddressCoinBalanceHistoryError> =
                serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
                entity: local_var_entity,
            };
            Err(Error::ResponseError(local_var_error))
        }
    }

    async fn get_address_coin_balance_history_by_day(
        &self,
        params: GetAddressCoinBalanceHistoryByDayParams,
    ) -> Result<
        ResponseContent<GetAddressCoinBalanceHistoryByDaySuccess>,
        Error<GetAddressCoinBalanceHistoryByDayError>,
    > {
        let GetAddressCoinBalanceHistoryByDayParams { address_hash } = params;

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}/api/v2/addresses/{address_hash}/coin-balance-history-by-day",
            local_var_configuration.base_path,
            address_hash = crate::apis::urlencode(address_hash)
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder
                .header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            let local_var_entity: Option<GetAddressCoinBalanceHistoryByDaySuccess> =
                serde_json::from_str(&local_var_content).ok();
            let local_var_result = ResponseContent {
                status: local_var_status,
                content: local_var_content,
                entity: local_var_entity,
            };
            Ok(local_var_result)
        } else {
            let local_var_entity: Option<GetAddressCoinBalanceHistoryByDayError> =
                serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
                entity: local_var_entity,
            };
            Err(Error::ResponseError(local_var_error))
        }
    }

    async fn get_address_counters(
        &self,
        params: GetAddressCountersParams,
    ) -> Result<ResponseContent<GetAddressCountersSuccess>, Error<GetAddressCountersError>> {
        let GetAddressCountersParams { address_hash } = params;

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}/api/v2/addresses/{address_hash}/counters",
            local_var_configuration.base_path,
            address_hash = crate::apis::urlencode(address_hash)
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder
                .header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            let local_var_entity: Option<GetAddressCountersSuccess> =
                serde_json::from_str(&local_var_content).ok();
            let local_var_result = ResponseContent {
                status: local_var_status,
                content: local_var_content,
                entity: local_var_entity,
            };
            Ok(local_var_result)
        } else {
            let local_var_entity: Option<GetAddressCountersError> =
                serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
                entity: local_var_entity,
            };
            Err(Error::ResponseError(local_var_error))
        }
    }

    async fn get_address_internal_txs(
        &self,
        params: GetAddressInternalTxsParams,
    ) -> Result<ResponseContent<GetAddressInternalTxsSuccess>, Error<GetAddressInternalTxsError>>
    {
        let GetAddressInternalTxsParams {
            address_hash,

            filter,
        } = params;

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}/api/v2/addresses/{address_hash}/internal-transactions",
            local_var_configuration.base_path,
            address_hash = crate::apis::urlencode(address_hash)
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

        if let Some(ref local_var_str) = filter {
            local_var_req_builder =
                local_var_req_builder.query(&[("filter", &local_var_str.to_string())]);
        }

        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder
                .header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            let local_var_entity: Option<GetAddressInternalTxsSuccess> =
                serde_json::from_str(&local_var_content).ok();
            let local_var_result = ResponseContent {
                status: local_var_status,
                content: local_var_content,
                entity: local_var_entity,
            };
            Ok(local_var_result)
        } else {
            let local_var_entity: Option<GetAddressInternalTxsError> =
                serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
                entity: local_var_entity,
            };
            Err(Error::ResponseError(local_var_error))
        }
    }

    async fn get_address_logs(
        &self,
        params: GetAddressLogsParams,
    ) -> Result<ResponseContent<GetAddressLogsSuccess>, Error<GetAddressLogsError>> {
        let GetAddressLogsParams { address_hash } = params;

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}/api/v2/addresses/{address_hash}/logs",
            local_var_configuration.base_path,
            address_hash = crate::apis::urlencode(address_hash)
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder
                .header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            let local_var_entity: Option<GetAddressLogsSuccess> =
                serde_json::from_str(&local_var_content).ok();
            let local_var_result = ResponseContent {
                status: local_var_status,
                content: local_var_content,
                entity: local_var_entity,
            };
            Ok(local_var_result)
        } else {
            let local_var_entity: Option<GetAddressLogsError> =
                serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
                entity: local_var_entity,
            };
            Err(Error::ResponseError(local_var_error))
        }
    }

    async fn get_address_nft(
        &self,
        params: GetAddressNftParams,
    ) -> Result<ResponseContent<GetAddressNftSuccess>, Error<GetAddressNftError>> {
        let GetAddressNftParams {
            address_hash,

            r#type,
        } = params;

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}/api/v2/addresses/{address_hash}/nft",
            local_var_configuration.base_path,
            address_hash = crate::apis::urlencode(address_hash)
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

        if let Some(ref local_var_str) = r#type {
            local_var_req_builder =
                local_var_req_builder.query(&[("type", &local_var_str.to_string())]);
        }

        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder
                .header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            let local_var_entity: Option<GetAddressNftSuccess> =
                serde_json::from_str(&local_var_content).ok();
            let local_var_result = ResponseContent {
                status: local_var_status,
                content: local_var_content,
                entity: local_var_entity,
            };
            Ok(local_var_result)
        } else {
            let local_var_entity: Option<GetAddressNftError> =
                serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
                entity: local_var_entity,
            };
            Err(Error::ResponseError(local_var_error))
        }
    }

    async fn get_address_nft_collections(
        &self,
        params: GetAddressNftCollectionsParams,
    ) -> Result<
        ResponseContent<GetAddressNftCollectionsSuccess>,
        Error<GetAddressNftCollectionsError>,
    > {
        let GetAddressNftCollectionsParams {
            address_hash,

            r#type,
        } = params;

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}/api/v2/addresses/{address_hash}/nft/collections",
            local_var_configuration.base_path,
            address_hash = crate::apis::urlencode(address_hash)
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

        if let Some(ref local_var_str) = r#type {
            local_var_req_builder =
                local_var_req_builder.query(&[("type", &local_var_str.to_string())]);
        }

        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder
                .header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            let local_var_entity: Option<GetAddressNftCollectionsSuccess> =
                serde_json::from_str(&local_var_content).ok();
            let local_var_result = ResponseContent {
                status: local_var_status,
                content: local_var_content,
                entity: local_var_entity,
            };
            Ok(local_var_result)
        } else {
            let local_var_entity: Option<GetAddressNftCollectionsError> =
                serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
                entity: local_var_entity,
            };
            Err(Error::ResponseError(local_var_error))
        }
    }

    async fn get_address_token_balances(
        &self,
        params: GetAddressTokenBalancesParams,
    ) -> Result<ResponseContent<GetAddressTokenBalancesSuccess>, Error<GetAddressTokenBalancesError>>
    {
        let GetAddressTokenBalancesParams { address_hash } = params;

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}/api/v2/addresses/{address_hash}/token-balances",
            local_var_configuration.base_path,
            address_hash = crate::apis::urlencode(address_hash)
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder
                .header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            let local_var_entity: Option<GetAddressTokenBalancesSuccess> =
                serde_json::from_str(&local_var_content).ok();
            let local_var_result = ResponseContent {
                status: local_var_status,
                content: local_var_content,
                entity: local_var_entity,
            };
            Ok(local_var_result)
        } else {
            let local_var_entity: Option<GetAddressTokenBalancesError> =
                serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
                entity: local_var_entity,
            };
            Err(Error::ResponseError(local_var_error))
        }
    }

    async fn get_address_token_transfers(
        &self,
        params: GetAddressTokenTransfersParams,
    ) -> Result<
        ResponseContent<GetAddressTokenTransfersSuccess>,
        Error<GetAddressTokenTransfersError>,
    > {
        let GetAddressTokenTransfersParams {
            address_hash,

            r#type,

            filter,

            token,
        } = params;

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}/api/v2/addresses/{address_hash}/token-transfers",
            local_var_configuration.base_path,
            address_hash = crate::apis::urlencode(address_hash)
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

        if let Some(ref local_var_str) = r#type {
            local_var_req_builder =
                local_var_req_builder.query(&[("type", &local_var_str.to_string())]);
        }

        if let Some(ref local_var_str) = filter {
            local_var_req_builder =
                local_var_req_builder.query(&[("filter", &local_var_str.to_string())]);
        }

        if let Some(ref local_var_str) = token {
            local_var_req_builder =
                local_var_req_builder.query(&[("token", &local_var_str.to_string())]);
        }

        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder
                .header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            let local_var_entity: Option<GetAddressTokenTransfersSuccess> =
                serde_json::from_str(&local_var_content).ok();
            let local_var_result = ResponseContent {
                status: local_var_status,
                content: local_var_content,
                entity: local_var_entity,
            };
            Ok(local_var_result)
        } else {
            let local_var_entity: Option<GetAddressTokenTransfersError> =
                serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
                entity: local_var_entity,
            };
            Err(Error::ResponseError(local_var_error))
        }
    }

    async fn get_address_tokens(
        &self,
        params: GetAddressTokensParams,
    ) -> Result<ResponseContent<GetAddressTokensSuccess>, Error<GetAddressTokensError>> {
        let GetAddressTokensParams {
            address_hash,

            r#type,
        } = params;

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}/api/v2/addresses/{address_hash}/tokens",
            local_var_configuration.base_path,
            address_hash = crate::apis::urlencode(address_hash)
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

        if let Some(ref local_var_str) = r#type {
            local_var_req_builder =
                local_var_req_builder.query(&[("type", &local_var_str.to_string())]);
        }

        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder
                .header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            let local_var_entity: Option<GetAddressTokensSuccess> =
                serde_json::from_str(&local_var_content).ok();
            let local_var_result = ResponseContent {
                status: local_var_status,
                content: local_var_content,
                entity: local_var_entity,
            };
            Ok(local_var_result)
        } else {
            let local_var_entity: Option<GetAddressTokensError> =
                serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
                entity: local_var_entity,
            };
            Err(Error::ResponseError(local_var_error))
        }
    }

    async fn get_address_txs(
        &self,
        params: GetAddressTxsParams,
    ) -> Result<ResponseContent<GetAddressTxsSuccess>, Error<GetAddressTxsError>> {
        let GetAddressTxsParams {
            address_hash,

            filter,
        } = params;

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}/api/v2/addresses/{address_hash}/transactions",
            local_var_configuration.base_path,
            address_hash = crate::apis::urlencode(address_hash)
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

        if let Some(ref local_var_str) = filter {
            local_var_req_builder =
                local_var_req_builder.query(&[("filter", &local_var_str.to_string())]);
        }

        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder
                .header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            let local_var_entity: Option<GetAddressTxsSuccess> =
                serde_json::from_str(&local_var_content).ok();
            let local_var_result = ResponseContent {
                status: local_var_status,
                content: local_var_content,
                entity: local_var_entity,
            };
            Ok(local_var_result)
        } else {
            let local_var_entity: Option<GetAddressTxsError> =
                serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
                entity: local_var_entity,
            };
            Err(Error::ResponseError(local_var_error))
        }
    }

    async fn get_address_withdrawals(
        &self,
        params: GetAddressWithdrawalsParams,
    ) -> Result<ResponseContent<GetAddressWithdrawalsSuccess>, Error<GetAddressWithdrawalsError>>
    {
        let GetAddressWithdrawalsParams { address_hash } = params;

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!(
            "{}/api/v2/addresses/{address_hash}/withdrawals",
            local_var_configuration.base_path,
            address_hash = crate::apis::urlencode(address_hash)
        );
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder
                .header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            let local_var_entity: Option<GetAddressWithdrawalsSuccess> =
                serde_json::from_str(&local_var_content).ok();
            let local_var_result = ResponseContent {
                status: local_var_status,
                content: local_var_content,
                entity: local_var_entity,
            };
            Ok(local_var_result)
        } else {
            let local_var_entity: Option<GetAddressWithdrawalsError> =
                serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
                entity: local_var_entity,
            };
            Err(Error::ResponseError(local_var_error))
        }
    }

    async fn get_addresses(
        &self,
    ) -> Result<ResponseContent<GetAddressesSuccess>, Error<GetAddressesError>> {
        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!("{}/api/v2/addresses", local_var_configuration.base_path);
        let mut local_var_req_builder =
            local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder
                .header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            let local_var_entity: Option<GetAddressesSuccess> =
                serde_json::from_str(&local_var_content).ok();
            let local_var_result = ResponseContent {
                status: local_var_status,
                content: local_var_content,
                entity: local_var_entity,
            };
            Ok(local_var_result)
        } else {
            let local_var_entity: Option<GetAddressesError> =
                serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent {
                status: local_var_status,
                content: local_var_content,
                entity: local_var_entity,
            };
            Err(Error::ResponseError(local_var_error))
        }
    }
}

/// struct for typed successes of method [`get_address`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAddressSuccess {
    Status200(models::Address),

    UnknownValue(serde_json::Value),
}

// changed
impl ResponseContent<GetAddressSuccess> {
    pub fn try_as_success(&self) -> Option<&models::Address> {
        match &self.entity {
            Some(GetAddressSuccess::Status200(data)) => Some(data),
            _ => None,
        }
    }

    pub fn try_parse_as_success_model(
        &self,
    ) -> Result<models::Address, serde_json_path_to_error::Error> {
        serde_json_path_to_error::from_str(&self.content)
    }
}

/// struct for typed successes of method [`get_address_blocks_validated`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAddressBlocksValidatedSuccess {
    Status200(models::GetAddressBlocksValidated200Response),

    UnknownValue(serde_json::Value),
}

// changed
impl ResponseContent<GetAddressBlocksValidatedSuccess> {
    pub fn try_as_success(&self) -> Option<&models::GetAddressBlocksValidated200Response> {
        match &self.entity {
            Some(GetAddressBlocksValidatedSuccess::Status200(data)) => Some(data),
            _ => None,
        }
    }

    pub fn try_parse_as_success_model(
        &self,
    ) -> Result<models::GetAddressBlocksValidated200Response, serde_json_path_to_error::Error> {
        serde_json_path_to_error::from_str(&self.content)
    }
}

/// struct for typed successes of method [`get_address_coin_balance_history`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAddressCoinBalanceHistorySuccess {
    Status200(models::GetAddressCoinBalanceHistory200Response),

    UnknownValue(serde_json::Value),
}

// changed
impl ResponseContent<GetAddressCoinBalanceHistorySuccess> {
    pub fn try_as_success(&self) -> Option<&models::GetAddressCoinBalanceHistory200Response> {
        match &self.entity {
            Some(GetAddressCoinBalanceHistorySuccess::Status200(data)) => Some(data),
            _ => None,
        }
    }

    pub fn try_parse_as_success_model(
        &self,
    ) -> Result<models::GetAddressCoinBalanceHistory200Response, serde_json_path_to_error::Error>
    {
        serde_json_path_to_error::from_str(&self.content)
    }
}

/// struct for typed successes of method [`get_address_coin_balance_history_by_day`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAddressCoinBalanceHistoryByDaySuccess {
    Status200(Vec<models::CoinBalanceHistoryByDaysEntry>),

    UnknownValue(serde_json::Value),
}

// changed
impl ResponseContent<GetAddressCoinBalanceHistoryByDaySuccess> {
    pub fn try_as_success(&self) -> Option<&Vec<models::CoinBalanceHistoryByDaysEntry>> {
        match &self.entity {
            Some(GetAddressCoinBalanceHistoryByDaySuccess::Status200(data)) => Some(data),
            _ => None,
        }
    }

    pub fn try_parse_as_success_model(
        &self,
    ) -> Result<Vec<models::CoinBalanceHistoryByDaysEntry>, serde_json_path_to_error::Error> {
        serde_json_path_to_error::from_str(&self.content)
    }
}

/// struct for typed successes of method [`get_address_counters`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAddressCountersSuccess {
    Status200(models::AddressCounters),

    UnknownValue(serde_json::Value),
}

// changed
impl ResponseContent<GetAddressCountersSuccess> {
    pub fn try_as_success(&self) -> Option<&models::AddressCounters> {
        match &self.entity {
            Some(GetAddressCountersSuccess::Status200(data)) => Some(data),
            _ => None,
        }
    }

    pub fn try_parse_as_success_model(
        &self,
    ) -> Result<models::AddressCounters, serde_json_path_to_error::Error> {
        serde_json_path_to_error::from_str(&self.content)
    }
}

/// struct for typed successes of method [`get_address_internal_txs`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAddressInternalTxsSuccess {
    Status200(models::GetAddressInternalTxs200Response),

    UnknownValue(serde_json::Value),
}

// changed
impl ResponseContent<GetAddressInternalTxsSuccess> {
    pub fn try_as_success(&self) -> Option<&models::GetAddressInternalTxs200Response> {
        match &self.entity {
            Some(GetAddressInternalTxsSuccess::Status200(data)) => Some(data),
            _ => None,
        }
    }

    pub fn try_parse_as_success_model(
        &self,
    ) -> Result<models::GetAddressInternalTxs200Response, serde_json_path_to_error::Error> {
        serde_json_path_to_error::from_str(&self.content)
    }
}

/// struct for typed successes of method [`get_address_logs`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAddressLogsSuccess {
    Status200(models::GetAddressLogs200Response),

    UnknownValue(serde_json::Value),
}

// changed
impl ResponseContent<GetAddressLogsSuccess> {
    pub fn try_as_success(&self) -> Option<&models::GetAddressLogs200Response> {
        match &self.entity {
            Some(GetAddressLogsSuccess::Status200(data)) => Some(data),
            _ => None,
        }
    }

    pub fn try_parse_as_success_model(
        &self,
    ) -> Result<models::GetAddressLogs200Response, serde_json_path_to_error::Error> {
        serde_json_path_to_error::from_str(&self.content)
    }
}

/// struct for typed successes of method [`get_address_nft`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAddressNftSuccess {
    Status200(models::GetAddressNft200Response),

    UnknownValue(serde_json::Value),
}

// changed
impl ResponseContent<GetAddressNftSuccess> {
    pub fn try_as_success(&self) -> Option<&models::GetAddressNft200Response> {
        match &self.entity {
            Some(GetAddressNftSuccess::Status200(data)) => Some(data),
            _ => None,
        }
    }

    pub fn try_parse_as_success_model(
        &self,
    ) -> Result<models::GetAddressNft200Response, serde_json_path_to_error::Error> {
        serde_json_path_to_error::from_str(&self.content)
    }
}

/// struct for typed successes of method [`get_address_nft_collections`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAddressNftCollectionsSuccess {
    Status200(models::GetAddressNftCollections200Response),

    UnknownValue(serde_json::Value),
}

// changed
impl ResponseContent<GetAddressNftCollectionsSuccess> {
    pub fn try_as_success(&self) -> Option<&models::GetAddressNftCollections200Response> {
        match &self.entity {
            Some(GetAddressNftCollectionsSuccess::Status200(data)) => Some(data),
            _ => None,
        }
    }

    pub fn try_parse_as_success_model(
        &self,
    ) -> Result<models::GetAddressNftCollections200Response, serde_json_path_to_error::Error> {
        serde_json_path_to_error::from_str(&self.content)
    }
}

/// struct for typed successes of method [`get_address_token_balances`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAddressTokenBalancesSuccess {
    Status200(Vec<models::TokenBalance>),

    UnknownValue(serde_json::Value),
}

// changed
impl ResponseContent<GetAddressTokenBalancesSuccess> {
    pub fn try_as_success(&self) -> Option<&Vec<models::TokenBalance>> {
        match &self.entity {
            Some(GetAddressTokenBalancesSuccess::Status200(data)) => Some(data),
            _ => None,
        }
    }

    pub fn try_parse_as_success_model(
        &self,
    ) -> Result<Vec<models::TokenBalance>, serde_json_path_to_error::Error> {
        serde_json_path_to_error::from_str(&self.content)
    }
}

/// struct for typed successes of method [`get_address_token_transfers`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAddressTokenTransfersSuccess {
    Status200(models::GetAddressTokenTransfers200Response),

    UnknownValue(serde_json::Value),
}

// changed
impl ResponseContent<GetAddressTokenTransfersSuccess> {
    pub fn try_as_success(&self) -> Option<&models::GetAddressTokenTransfers200Response> {
        match &self.entity {
            Some(GetAddressTokenTransfersSuccess::Status200(data)) => Some(data),
            _ => None,
        }
    }

    pub fn try_parse_as_success_model(
        &self,
    ) -> Result<models::GetAddressTokenTransfers200Response, serde_json_path_to_error::Error> {
        serde_json_path_to_error::from_str(&self.content)
    }
}

/// struct for typed successes of method [`get_address_tokens`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAddressTokensSuccess {
    Status200(models::GetAddressTokens200Response),

    UnknownValue(serde_json::Value),
}

// changed
impl ResponseContent<GetAddressTokensSuccess> {
    pub fn try_as_success(&self) -> Option<&models::GetAddressTokens200Response> {
        match &self.entity {
            Some(GetAddressTokensSuccess::Status200(data)) => Some(data),
            _ => None,
        }
    }

    pub fn try_parse_as_success_model(
        &self,
    ) -> Result<models::GetAddressTokens200Response, serde_json_path_to_error::Error> {
        serde_json_path_to_error::from_str(&self.content)
    }
}

/// struct for typed successes of method [`get_address_txs`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAddressTxsSuccess {
    Status200(models::GetBlockTxs200Response),

    UnknownValue(serde_json::Value),
}

// changed
impl ResponseContent<GetAddressTxsSuccess> {
    pub fn try_as_success(&self) -> Option<&models::GetBlockTxs200Response> {
        match &self.entity {
            Some(GetAddressTxsSuccess::Status200(data)) => Some(data),
            _ => None,
        }
    }

    pub fn try_parse_as_success_model(
        &self,
    ) -> Result<models::GetBlockTxs200Response, serde_json_path_to_error::Error> {
        serde_json_path_to_error::from_str(&self.content)
    }
}

/// struct for typed successes of method [`get_address_withdrawals`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAddressWithdrawalsSuccess {
    Status200(models::GetBlockWithdrawals200Response),

    UnknownValue(serde_json::Value),
}

// changed
impl ResponseContent<GetAddressWithdrawalsSuccess> {
    pub fn try_as_success(&self) -> Option<&models::GetBlockWithdrawals200Response> {
        match &self.entity {
            Some(GetAddressWithdrawalsSuccess::Status200(data)) => Some(data),
            _ => None,
        }
    }

    pub fn try_parse_as_success_model(
        &self,
    ) -> Result<models::GetBlockWithdrawals200Response, serde_json_path_to_error::Error> {
        serde_json_path_to_error::from_str(&self.content)
    }
}

/// struct for typed successes of method [`get_addresses`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAddressesSuccess {
    Status200(models::GetAddresses200Response),

    UnknownValue(serde_json::Value),
}

// changed
impl ResponseContent<GetAddressesSuccess> {
    pub fn try_as_success(&self) -> Option<&models::GetAddresses200Response> {
        match &self.entity {
            Some(GetAddressesSuccess::Status200(data)) => Some(data),
            _ => None,
        }
    }

    pub fn try_parse_as_success_model(
        &self,
    ) -> Result<models::GetAddresses200Response, serde_json_path_to_error::Error> {
        serde_json_path_to_error::from_str(&self.content)
    }
}

/// struct for typed errors of method [`get_address`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAddressError {
    Status400(),

    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_address_blocks_validated`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAddressBlocksValidatedError {
    Status400(),

    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_address_coin_balance_history`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAddressCoinBalanceHistoryError {
    Status400(),

    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_address_coin_balance_history_by_day`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAddressCoinBalanceHistoryByDayError {
    Status400(),

    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_address_counters`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAddressCountersError {
    Status400(),

    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_address_internal_txs`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAddressInternalTxsError {
    Status400(),

    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_address_logs`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAddressLogsError {
    Status400(),

    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_address_nft`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAddressNftError {
    Status400(),

    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_address_nft_collections`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAddressNftCollectionsError {
    Status400(),

    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_address_token_balances`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAddressTokenBalancesError {
    Status400(),

    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_address_token_transfers`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAddressTokenTransfersError {
    Status400(),

    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_address_tokens`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAddressTokensError {
    Status400(),

    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_address_txs`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAddressTxsError {
    Status400(),

    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_address_withdrawals`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAddressWithdrawalsError {
    Status400(),

    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_addresses`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAddressesError {
    Status400(),

    UnknownValue(serde_json::Value),
}
